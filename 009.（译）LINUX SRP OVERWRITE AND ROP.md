## Linux SRP 覆写和 ROP

最近我开始在 Twitch 上直播一些与安全相关的东西，因为我很喜欢向别人教授并展示我使用的技术，工具以及整个过程，同时我也会努力将这些东西系统化，而不是吸收一些零散的碎片。昨晚我完成了我的第二场直播，主要是针对以下几点：


* 对易受攻击的 32 位 Linux 二进制文件的快速分析；
* 解释为什么栈缓冲区溢出会导致返回地址(SRP)被重写；
* 描述如何通过 SRP 重写来控制 EIP 寄存器；
* 演示如何通过这种控制来执行未启用 NX 的栈上的 shellcode；
* 编写一个使用这种缺陷的利用程序，执行被攻击者控制的代码。


在第一个二进制的前提下，第二个也就更容易了。第二个二进制文件与前一个相差无几，只是它是使用 NX 编译的，因此之前的利用程序也就无效了。本节主要包含以下几点：

* NX 导致之前的漏洞不能使用的原因；
* 如何控制 EIP，使其依然可以被用来执行大块的代码；
* ROP 的“合理”描述，以及它是如何工作的；
* 在操作中 ROP 的演示（这里比较单调乏味，是为了让之前没有见过这种方式的人更容易理解）；
* 构造一个利用程序来导致代码执行，即使已开启NX。


这个视频的后半部分没有提前计划，比我预计的时间结束得要早一些。最后的利用程序是专门针对于我正在运行的机子（ Fedora Core 24 ），因此没法在远程系统上使用。其实，我最开始的想法是演示如何可能通过读取整个内存区域，来搜索感兴趣的指令（这种情况下是 int  0x80;  ret ）。考虑到时间关系，我最后决定跳过这种方式，用更简单的方式实现它。

该视频已发布到 YouTube ，链接在[这里](https://www.youtube.com/watch?v=XOmawM1EXnM&feature=youtu.be)。

对于嵌入 YouTube 视频剪辑时默认包含的 DoubleClick 以及  Javascript crap ，我深表歉意。为了使你不留下痕迹，请运行 uBlock 或者类似的程序。

最后，我将这两个二进制文件放在[这里](http://buffered.io/posts/linux-srp-overwrite-and-rop/)，以供大家使用。

对于由字体大小所引起的不满，我非常抱歉，我经常不知道我正在做什么。如果你有任何问题或者意见，欢迎来打我！谢谢！
